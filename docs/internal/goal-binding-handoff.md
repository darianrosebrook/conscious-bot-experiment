# Goal Binding Protocol — Implementation Handoff

Companion to [`goal-binding-protocol.md`](goal-binding-protocol.md) (the specification). That document defines *what* the protocol must do. This document records *what was built*, *how each invariant is proven*, and *what remains* for integration.

**Status**: All pure-layer goal-binding modules implemented and tested. Partial integration exists only for goal-task routing behind `ENABLE_GOAL_BINDING`; lifecycle hook wiring, reactor drivers, periodic review drivers, and solver anchoring are not yet connected to the runtime.

**Test posture**:

- Pure layer (goals module): 280 tests across 15 files, 0 failures.
  Command: `npx vitest run packages/planning/src/goals/__tests__`
- Full surface including TaskIntegration routing: 293 tests across 16 files, 0 failures.
  Command: `npx vitest run packages/planning/src/goals/__tests__ packages/planning/src/task-integration/__tests__/goal-resolver-routing.test.ts`

**Scope boundary**: This protocol governs identity, deduplication, holds, completion verification, and state coordination for goal-bound tasks. It does not implement world mutation, checkpointed module execution, crash recovery, or repair. Those are execution-substrate concerns described in [`long-horizon-build.md`](long-horizon-build.md) (Stages 0.5–2). The protocol can be "complete" while long-horizon building remains incomplete — construction leaves are currently stubs that do not place blocks in the world.

### Identity glossary

Three identifiers appear throughout the protocol. They serve different purposes and must not be conflated:

| Identifier | Type | Source | Mutability | Purpose |
|------------|------|--------|------------|---------|
| `goalInstanceId` | `string` (UUID) | Generated at task creation by `GoalResolver` | **Immutable** — never changes | All internal references: event payloads, parent/child links, logs, hold witnesses. The canonical identity for a goal-task binding across its entire lifetime. |
| `goalId` | `string \| undefined` | Set by caller when `GoalManager` spawns the task | **Immutable** once set, but optional | Back-reference to `Goal.id` in `GoalManager`. Used by `reduceTaskEvent()` to target goal status updates and by `reduceGoalEvent()` to filter bound tasks. If absent, task→goal sync produces noop. |
| `task.id` | `string` | Generated by `TaskIntegration` | **Immutable** | Execution identity. Used by the task store, step completion, and status transitions. The protocol reads it but does not own it. |

When P0.2 wires `GoalManager.pause()` / `resume()` / `cancel()` to `onGoalAction()`, the implementation must collect bound tasks via `goalBinding.goalId === goal.id`. This requires that `goalId` was populated at task creation time. If `goalId` is absent on a binding, the task is invisible to goal-level actions — it can still be managed directly via task commands but won't respond to goal pause/resume/cancel propagation.

### Protocol fields requiring execution substrate

Several protocol fields are read by the coordination layer but can only be meaningfully populated by the execution substrate (Stages 0.5–1 of `long-horizon-build.md`). Until the substrate writes them, protocol decisions based on these fields use fallback/default behavior:

| Field | Read by | Written by | Current state |
|-------|---------|------------|---------------|
| `task.metadata.build.moduleCursor` / `totalModules` | Verifier (`verifyShelterV0` — module completion check), Resolver (progress scoring), Preemption witness | Building solver / module execution runner | **Not written at runtime.** Verifier skips module check when absent. Resolver scores progress as 0. Preemption witness records `moduleCursor: undefined`. |
| `HoldWitness.lastStepId` | Preemption coordinator, resume logic | Execution runner (per-step, on preemption signal) | **Not written at runtime.** Safe-stop winddown cannot anchor to a real step boundary. Witness validity check (`isValidWitness`) returns false when neither `lastStepId` nor `moduleCursor` is present. |
| `goalBinding.anchors.siteSignature` | Verifier (world-state check gating), Resolver (anchor match scoring, spatial scope), Identity (Phase B key) | Building solver / bootstrap phase (`anchorGoalIdentity()`) | **Not called at runtime.** All tasks remain in Phase A (provisional key). Verifier skips world-state check when no siteSignature. Resolver uses proximity scoring only. |
| `task.steps[].done` | Verifier (all-steps-complete check), Completion checker | Step execution runner (`completeTaskStep()`) | **Written by existing infrastructure.** This field works today — the gap is that stub leaves mark steps done without actually mutating the world. |

---

## 1. Module inventory

Every module lives in `packages/planning/src/goals/`. Each is self-contained with no side effects on import.

| Module | Purpose | Key exports |
|--------|---------|-------------|
| `goal-binding-types.ts` | Type definitions | `GoalBinding`, `GoalHold`, `GoalAnchors`, `GoalCompletion`, `GoalHoldReason` |
| `goal-identity.ts` | Deterministic identity | `computeProvisionalKey()`, `computeAnchoredKey()`, `anchorGoalIdentity()`, `hashGoalKey()` |
| `goal-resolver.ts` | Atomic dedup | `GoalResolver.resolveOrCreate()`, scoring weights, `CONTINUE_THRESHOLD` |
| `keyed-mutex.ts` | Per-key async lock | `KeyedMutex`, `withKeyLock()` |
| `goal-task-sync.ts` | Pure reducer | `reduceTaskEvent()`, `reduceGoalEvent()`, `detectGoalTaskDrift()`, `resolveDrift()` |
| `goal-hold-manager.ts` | Hold lifecycle | `requestHold()`, `requestClearHold()`, `DEFAULT_REVIEW_INTERVAL_MS` |
| `goal-binding-normalize.ts` | Illegal state detection | `detectIllegalStates()`, `assertConsistentGoalState()`, `recordVerificationResult()` |
| `activation-reactor.ts` | Event-driven reactivation | `ActivationReactor.tick()`, budgets, hysteresis, manual_pause wall |
| `periodic-review.ts` | Backstop reconciliation | `runPeriodicReview()` |
| `completion-checker.ts` | Stability window | `checkCompletion()`, `applyCompletionOutcome()`, `STABILITY_THRESHOLD` |
| `verifier-registry.ts` | Verifier lookup | `VerifierRegistry`, `verifyShelterV0`, `createDefaultVerifierRegistry()` |
| `preemption-budget.ts` | Safe-stop winddown | `PreemptionCoordinator`, `createPreemptionBudget()`, `buildHoldWitness()` |
| `goal-lifecycle-events.ts` | Structured events | `GoalLifecycleCollector`, event factories, 12 event types |
| `goal-lifecycle-hooks.ts` | Integration hooks | `onTaskStatusChanged()`, `onGoalAction()`, `onTaskProgressUpdated()`, `applySyncEffects()` |

### Protocol boundary surface

These are the canonical entry points from the runtime into the goal-binding protocol:

| Entry point | Module | Status |
|-------------|--------|--------|
| Goal-sourced task creation | `GoalResolver.resolveOrCreate()` | Routed via `TaskIntegration.enableGoalResolver()` behind `ENABLE_GOAL_BINDING` feature gate |
| Task mutation events | `onTaskStatusChanged()` / `onTaskProgressUpdated()` | Defined in `goal-lifecycle-hooks.ts`; not wired to `TaskIntegration.updateTaskStatus()` |
| Goal actions | `onGoalAction()` | Defined in `goal-lifecycle-hooks.ts`; not wired to `GoalManager.pause()` / `resume()` / `cancel()` |
| Autonomy tick | `ActivationReactor.tick()` + `runPeriodicReview()` | Defined; no caller in executor or scheduler |
| Solver commit | `anchorGoalIdentity()` | Defined in `goal-identity.ts`; not called from building solver or bootstrap |

---

## 2. Invariants and how each is proven

Each invariant is a property the protocol guarantees. The "Proof" column references the specific test file(s) and describe block(s) that exercise it.

### 2.1 Identity

| Invariant | Proof |
|-----------|-------|
| `goalInstanceId` never changes across Phase A→B transition | `goal-identity.test.ts` > "goalInstanceId unchanged after anchoring" |
| Phase A→B is a one-way transition (double-anchor throws) | `review-artifacts.test.ts` > Artifact B > "anchor transition is atomic" |
| Old provisional key preserved in `goalKeyAliases` after anchoring | `goal-identity.test.ts` > "old key moved to aliases"; `review-artifacts.test.ts` > Artifact A Phase 3 |
| Shelter identity excludes template digest; structure includes it | `goal-identity.test.ts` > shelter vs structure anchored key tests |
| Anchor atomicity: all three writes (alias, key, siteSignature) consistent | `review-artifacts.test.ts` > Artifact B > "anchor transition is atomic" (synchronous function + partial-write detection via `anchored_without_alias` rule) |

### 2.2 Uniqueness and deduplication

| Invariant | Proof |
|-----------|-------|
| At most one non-terminal task per (goalType, goalKey) | `goal-resolver-atomic.test.ts` > "20 concurrent intents → 1 created"; `review-artifacts.test.ts` > Artifact C (20 and 50 concurrent requests) |
| Different chunks produce independent tasks | `review-artifacts.test.ts` > Artifact C > "different chunks create independent tasks" |
| Resolver finds tasks by alias (Phase A key still resolves after Phase B transition) | `goal-resolver.test.ts` > alias lookup tests |
| Uniqueness is guaranteed only within a single Node.js process; no multi-process safety is claimed | `keyed-mutex.ts:8-9` (source-level boundary); `review-artifacts.test.ts` > Artifact C topology boundary comment |

If multi-process deployment is introduced, a store-level uniqueness constraint keyed on `(goalType, goalKey, nonTerminal)` or a distributed lock is required.

### 2.3 Manual pause hard wall

| Invariant | Proof |
|-----------|-------|
| `goal_resumed` event produces `noop` for `manual_pause` tasks | `review-artifacts.test.ts` > D.2; `goal-task-sync.test.ts` > manual_pause noop |
| `requestClearHold()` without `forceManual: true` returns `blocked_manual_pause` | `goal-hold-manager.test.ts` > manual_pause blocking; `review-artifacts.test.ts` > Artifact B hold snapshots |
| `ActivationReactor.tick()` skips manually paused tasks | `activation-reactor.test.ts` > manual_pause eligibility |
| `runPeriodicReview()` produces noop for manual_pause | `periodic-review.test.ts` > manual_pause noop |

Three-layer defense: hold manager refuses clear, sync reducer produces noop, activation reactor skips. All three layers tested independently.

### 2.4 Hold protocol

| Invariant | Proof |
|-----------|-------|
| `requestHold()` mirrors to `blockedReason` and `nextEligibleAt` | `goal-hold-manager.test.ts` > field mirroring; `review-artifacts.test.ts` > Artifact B hold snapshots |
| `requestClearHold()` clears hold + mirrored fields | `goal-hold-manager.test.ts` > clear tests |
| `nextReviewAt` is deterministic given frozen time | `review-artifacts.test.ts` > Artifacts A, B (exact values with `vi.useFakeTimers()`) |
| Preemption budget exhausts after 3 steps or 5 seconds | `preemption-budget.test.ts` > step/time exhaustion |
| HoldWitness captures `lastStepId` and `moduleCursor` | `preemption-budget.test.ts` > witness tests |

### 2.5 Completion and regression

| Invariant | Proof |
|-----------|-------|
| `STABILITY_THRESHOLD = 2` consecutive passes required | `completion-checker.test.ts` > stability window; `review-artifacts.test.ts` > D.9 |
| First pass → `progressing`, second pass → `completed` | `completion-checker.test.ts` > first/second pass; `review-artifacts.test.ts` > Artifact A Phases 7-8 |
| Failure resets `consecutivePasses` to 0 | `completion-checker.test.ts` > failure reset; `review-artifacts.test.ts` > D.9 |
| Completed task failing verification → `regression` (re-opened) | `completion-checker.test.ts` > regression; `review-artifacts.test.ts` > Artifact A Phase 9 |
| `applyCompletionOutcome` sets `completedAt`, `actualDuration`, `progress=1.0` | `completion-checker.test.ts` > applyCompletionOutcome |
| No `goalBinding` → `skipped` (non-goal tasks unaffected) | `completion-checker.test.ts` > edge cases |

### 2.6 Sync reducer

| Invariant | Proof |
|-----------|-------|
| Task status changes map to correct goal statuses | `goal-task-sync.test.ts` > status mapping; `review-artifacts.test.ts` > D.1 |
| `goal_paused` produces hold + pause effects for non-terminal tasks only | `goal-task-sync.test.ts`; `review-artifacts.test.ts` > D.3 |
| `goal_cancelled` produces fail effects | `review-artifacts.test.ts` > D.4 |
| Drift detection finds mismatches, `resolveDrift()` corrects them | `goal-task-sync.test.ts` > drift; `review-artifacts.test.ts` > D.5 |
| Mixed hold types in same `goal_resumed`: manual blocks, preempted clears | `review-artifacts.test.ts` > D.6 |
| Non-goal-bound tasks → noop | `review-artifacts.test.ts` > D.7 |
| Reducer is idempotent (full deep equality under frozen time) | `review-artifacts.test.ts` > D.8 |

### 2.7 Illegal state detection

| Invariant | Proof |
|-----------|-------|
| `paused_without_hold`: status=paused but no hold object | `goal-binding-normalize.test.ts` |
| `non_paused_with_hold`: status=active but hold exists | `goal-binding-normalize.test.ts` |
| `manual_pause_mismatch`: hold.reason=manual_pause but blockedReason differs | `goal-binding-normalize.test.ts` |
| `done_but_not_completed`: consecutivePasses >= threshold but status != completed | `goal-binding-normalize.test.ts` |
| `anchored_without_alias`: siteSignature set but aliases empty | `goal-binding-normalize.test.ts`; `review-artifacts.test.ts` > Artifact B |

---

## 3. Review artifacts

`review-artifacts.test.ts` contains 17 structured proof-artifact tests, organized as four artifacts:

| Artifact | Tests | What it proves |
|----------|-------|----------------|
| **A: Golden Lifecycle Trace** | 1 | Full 9-event lifecycle: create → dedup → anchor → manual_pause → hard-wall → force-clear → verify×2 → complete → regression. All assertions inline at each boundary. |
| **B: Store Snapshot Before/After** | 3 | Concrete state diffs, anchor atomicity (synchronous + partial-write detection + double-anchor rejection), hold state comparison (preempted vs manual_pause). |
| **C: Concurrency** | 3 | 20 concurrent resolves → exactly 1 created; different chunks → independent tasks; 50 requests stress test. Topology boundary documented. |
| **D: Reducer Golden Vectors** | 10 | D.1–D.9: status mapping, manual_pause hard wall, goal_paused/cancelled/resumed, drift, mixed holds, non-goal noop, idempotence, stability window reset. |

All artifacts use `vi.useFakeTimers()` with `FROZEN_TIME = new Date('2025-01-15T12:00:00Z').getTime()` for fully deterministic assertions including `nextReviewAt`, `lastVerifiedAt`, and `completedAt`.

---

## 4. Design decisions worth noting

### Pure reducers, no mutations

`reduceTaskEvent()` and `reduceGoalEvent()` return `SyncEffect[]` arrays. The caller is responsible for applying effects via `applySyncEffects()`. This separation means:
- Reducers are testable without a store
- Effects are inspectable before application
- The same reducer can drive different stores (in-memory, persistent, distributed)

### Trace-only events (non-proof)

`review-artifacts.test.ts` constructs `goal_anchored`, `goal_hold_applied`, and `goal_hold_cleared` events inline using `traceAnchoredEvent()` / `traceHoldAppliedEvent()` / `traceHoldClearedEvent()`. These are **not** emitted by production code — no factory functions exist in `goal-lifecycle-events.ts` for these types yet. The trace constructors model what a production emitter would produce; they prove nothing about actual emission. The lifecycle trace events in the review artifacts are documentary scaffolding; the proof of behavior is the inline state assertions and reducer outputs, not event emission.

### Sentinel value: `FROZEN_TIME + Number.MAX_SAFE_INTEGER`

`manual_pause` uses `MANUAL_PAUSE_REVIEW_INTERVAL_MS = 0` in `goal-hold-manager.ts`, which produces `nextReviewAt = Date.now() + (0 || Number.MAX_SAFE_INTEGER)` — effectively infinite. This is a deliberate design choice: no periodic review will ever fire for manual_pause because `now >= nextReviewAt` can never be true. The numeric value exceeds `MAX_SAFE_INTEGER` after addition; we treat it as an unreachable sentinel rather than a safely representable timestamp. A future cleanup could use a dedicated `NEVER` sentinel constant.

### Scoring weights

Goal resolver scoring: `keyMatch*0.65 + anchorMatch*0.15 + proximity*0.1 + progress*0.05 + recency*0.1`. The `CONTINUE_THRESHOLD = 0.6` means an exact key match alone is sufficient to continue (0.65 > 0.6), which is correct — if the goalKey matches, it's the same goal.

---

## 5. What is not done — integration wiring

The pure layer is complete. Runtime wiring is incomplete; only goal-task routing is feature-gated and integrated (see protocol boundary surface in section 1). The following describes what remains, in priority order.

### P0: Wire state transitions through the protocol

**Acceptance criteria** (each phrased as an executable scenario):

#### P0.1: Task status transitions propagate through the protocol

**Where**: `packages/planning/src/task-integration.ts`, `updateTaskStatus()` (~line 228)

**Acceptance test** (observable outcome):
```
Given a goal-bound task transitions status active → paused via TaskIntegration
Then the protocol must:
  - Apply a hold consistent with the pause reason
    (or the manual_pause path when initiated by the management handler)
  - Mirror hold state into blockedReason / nextEligibleAt fields
  - Update the goal's status to reflect the bound task set (if applicable)
  - Preserve illegal-state invariants (assertConsistentGoalState remains true)
```

*Implementation note*: achieved by routing status changes through `onTaskStatusChanged()` and applying effects via `applySyncEffects()`. The completion check path fires on transitions to `completed` or progress reaching 1.0.

#### P0.2: Goal actions propagate to bound tasks

**Where**: `packages/planning/src/goal-formulation/goal-manager.ts`, `pause()` / `resume()` / `cancel()` methods

**Acceptance test** (observable outcome):
```
Given a goal with 2 bound active tasks
When the goal is paused with reason='unsafe'
Then both bound tasks transition to status=paused
And both tasks have goalBinding.hold.reason='unsafe'
And blockedReason / nextEligibleAt are mirrored
And assertConsistentGoalState passes for both tasks
```

*Implementation note*: achieved by collecting bound tasks where `goalBinding.goalId === goal.id` (see identity glossary above), calling `onGoalAction()`, and applying the returned effects. Tasks without `goalId` on their binding are invisible to goal-level propagation.

#### P0.3: User pause/resume commands use the hold protocol for goal-bound tasks

**Where**: The management handler that processes `pause` / `resume` commands

**Acceptance test** (observable outcome):
```
Given a goal-bound task in status=active
When management handler receives 'pause' command
Then task.status = 'paused'
And goalBinding.hold.reason = 'manual_pause'
And blockedReason = 'manual_pause'
And nextReviewAt is effectively infinite (unreachable sentinel)
And no reactor tick or periodic review can clear this hold

Given a goal-bound task held with manual_pause
When management handler receives 'resume' command
Then hold is cleared, task transitions to pending
And assertConsistentGoalState passes
```

*Implementation note*: achieved by routing goal-bound pause through `requestHold(task, 'manual_pause')` and resume through `requestClearHold(task, { forceManual: true })`.

### P1: Add autonomy layer drivers

#### P1.1: ActivationReactor.tick() called from executor

**Where**: The main execution loop or a scheduler (~100ms–1s interval)

**What**: Call `reactor.tick(allTasks, context)` where context provides `getGoalStatus`, `botPosition`, current events.

**Acceptance test**:
```
Given a held task with reason='materials_missing' and nextReviewAt in the past
When reactor.tick fires with materials now available
Then task transitions from paused → pending
And at most MAX_REACTIVATE_PER_MINUTE (2) tasks are reactivated per minute
```

#### P1.2: Periodic review on timer

**Where**: Server startup or executor initialization

**What**: Call `runPeriodicReview(allTasks, getGoalStatus)` on a ~60s interval. Apply returned effects.

**Acceptance test**:
```
Given a held task with nextReviewAt 90 seconds ago
When periodic review fires
Then the task is reconsidered
And if feasible, transitions to pending
And manual_pause tasks are skipped (noop)
```

#### P1.3: anchorGoalIdentity when solver commits site

**Where**: Building solver or bootstrap phase, when `siteSignature` is determined

**What**: Call `anchorGoalIdentity(binding, { refCorner, facing, siteSignature })` once the solver selects a build site.

**Acceptance test**:
```
Given a goal-bound task with provisional key (Phase A)
When solver commits site at (100, 64, 200) facing N
Then goalKey transitions to anchored (Phase B)
And old provisional key is in goalKeyAliases
And goalInstanceId is unchanged
```

---

## 6. Test file map

| File | Tests | Focus |
|------|-------|-------|
| `goal-binding-types.test.ts` | shape | Type construction, field presence |
| `keyed-mutex.test.ts` | 8 | Acquire/release, contention, per-key isolation |
| `goal-identity.test.ts` | 18 | Provisional key, anchored key, Phase A→B, alias tracking, shelter vs structure |
| `goal-resolver.test.ts` | 14 | Scoring, continue/create/satisfied outcomes, dry resolve |
| `goal-resolver-atomic.test.ts` | 6 | Concurrent resolution, uniqueness invariant |
| `goal-task-sync.test.ts` | 22 | Task→Goal and Goal→Task reducer, drift detection |
| `goal-hold-manager.test.ts` | 15 | Hold apply/clear, manual_pause wall, field mirroring |
| `activation-reactor.test.ts` | 16 | Tick behavior, budgets, hysteresis, manual_pause skip |
| `periodic-review.test.ts` | 10 | Backstop review, stale hold cleanup, manual_pause noop |
| `goal-lifecycle-events.test.ts` | 12 | Event construction, collector, filtering, max size |
| `completion-checker.test.ts` | 10 | Stability window, regression, apply outcome |
| `goal-lifecycle-hooks.test.ts` | 13 | Hook integration, effect production, applySyncEffects |
| `preemption-budget.test.ts` | 14 | Budget create/consume/exhaust, coordinator lifecycle |
| `verifier-registry.test.ts` | 11 | Registry CRUD, verify dispatch, worldState passthrough |
| `review-artifacts.test.ts` | 17 | Artifacts A-D: lifecycle trace, store snapshots, concurrency, reducer vectors |

**Pure layer total: 280 tests, 15 files, 0 failures.**

Including the TaskIntegration routing test (`goal-resolver-routing.test.ts`, 13 tests): **293 tests, 16 files, 0 failures.**

---

## 7. Commands

```bash
# Run pure-layer goal-binding tests (280 tests / 15 files)
npx vitest run packages/planning/src/goals/__tests__

# Run full surface including routing (293 tests / 16 files)
npx vitest run packages/planning/src/goals/__tests__ packages/planning/src/task-integration/__tests__/goal-resolver-routing.test.ts

# Run with verbose output
npx vitest run packages/planning/src/goals/__tests__ --reporter=verbose

# Run a single artifact
npx vitest run packages/planning/src/goals/__tests__/review-artifacts.test.ts

# Typecheck
npx tsc --noEmit
```

---

## 8. Integration file status

### Already changed (feature-gated routing exists)

| File | What exists |
|------|-------------|
| `packages/planning/src/task-integration.ts` | Goal-sourced task routing via `enableGoalResolver()` (~line 730); `GoalResolver.resolveOrCreate()` called for goal-bound task creation |
| `packages/planning/src/interfaces/task-integration.ts` | `enableGoalResolver()` method and config flag on the interface |
| `packages/planning/src/modular-server.ts` | `ENABLE_GOAL_BINDING` environment variable gate (~line 2921) |
| `packages/planning/src/task-integration/__tests__/goal-resolver-routing.test.ts` | 13 tests proving resolver routing behind feature gate |

### Still needs changes (P0/P1 wiring)

| File | Change needed |
|------|---------------|
| `packages/planning/src/task-integration.ts` | Wire lifecycle hooks on status/progress transitions; apply returned effects via `applySyncEffects()` |
| `packages/planning/src/goal-formulation/goal-manager.ts` | Wire `onGoalAction()` for `pause()` / `resume()` / `cancel()`; apply returned effects to bound tasks |
| Task management handler (command processing) | Route `pause`/`resume` through `requestHold()`/`requestClearHold()` for goal-bound tasks |
| Executor or server startup | Drive `ActivationReactor.tick()`; schedule `runPeriodicReview()` on ~60s interval |
| Building solver / bootstrap | Call `anchorGoalIdentity()` when solver commits site |
| `packages/planning/src/goals/goal-lifecycle-events.ts` | Optional: add factory functions for `goal_anchored`, `goal_hold_applied`, `goal_hold_cleared` (currently trace-only) |
