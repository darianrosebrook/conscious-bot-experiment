/**
 * Keep-Alive Controller
 *
 * Provides a non-injective pathway that allows (but does not compel) goal emission.
 *
 * Key invariants:
 * - I-1: No goal injection — presents facts, never proposes candidate actions/goals
 * - I-2: Autonomy is optional — "no action" is a valid steady state
 * - I-3: Action only via explicit intent — goals come from model, not system
 * - I-4: Planning owns `processed=true` — cognition doesn't pre-ack planning work
 *
 * Design:
 * - Uses production reasoning surface (LF-4)
 * - Single eligibility choke point (LF-2)
 * - Idle detection gate (LF-9)
 * - Rate limiting with stimulus acceleration
 * - Circuit breaker for perception refresh
 *
 * @author @darianrosebrook
 */

import { EventEmitter } from 'events';

// Import production reasoning surface (LF-4)
import {
  renderSituationFrame,
  processLLMOutput,
  processLLMOutputAsync,
  thoughtContextToFrameContext,
  FRAME_PROFILES,
  type FrameProfile,
  type FrameContext,
  type GroundingContext,
  type GoalTagV1,
  type EligibilityOutput,
  type GroundingResult,
  type SterlingPipelineResult,
} from '../reasoning-surface';

// Import keep-alive modules
import {
  detectIdle,
  buildIdleContext,
  estimateThreatLevel,
  type IdleContext,
  type IdleDecision,
  type IdleDetectorConfig,
  DEFAULT_IDLE_CONFIG,
} from './idle-detector';

import { renderIntentionCheckPrompt, type IntentionCheckVariant } from './intention-check-prompt';

import {
  type KeepAliveEvent,
  type KeepAliveTickPayload,
  type KeepAliveThoughtPayload,
  createTickEvent,
  createThoughtEvent,
  createSkipNotIdleEvent,
  createViolationEvent,
} from './event-types';

// ============================================================================
// Types
// ============================================================================

/**
 * Configuration for the keep-alive controller.
 */
export interface KeepAliveConfig {
  /** Base interval between ticks (ms) - default 120000 (2 min) */
  baseIntervalMs: number;
  /** Minimum interval (with maximum acceleration) - default 30000 (30s) */
  minIntervalMs: number;
  /** Maximum perception refreshes per minute (circuit breaker) */
  maxRefreshesPerMinute: number;
  /** How often to check idle state (ms) */
  idleCheckIntervalMs: number;
  /** Frame profile to use */
  frameProfile: FrameProfile['name'];
  /** Prompt variant to use */
  promptVariant: IntentionCheckVariant;
  /** Stimulus acceleration factors */
  stimulusAcceleration: Record<string, number>;
  /** Idle detection configuration */
  idleConfig: IdleDetectorConfig;
}

/**
 * Default configuration.
 */
export const DEFAULT_KEEPALIVE_CONFIG: KeepAliveConfig = {
  baseIntervalMs: 120_000,        // 2 minutes
  minIntervalMs: 30_000,          // 30 seconds minimum
  maxRefreshesPerMinute: 3,       // Circuit breaker
  idleCheckIntervalMs: 5_000,     // 5 seconds
  frameProfile: 'balanced',
  promptVariant: 'standard',
  stimulusAcceleration: {
    damage_event: 4.0,      // → 30s
    threat_delta: 3.0,      // → 40s
    health_drop: 3.0,       // → 40s
    hunger_drop: 2.0,       // → 60s
    novel_entity: 2.0,      // → 60s
  },
  idleConfig: DEFAULT_IDLE_CONFIG,
};

/**
 * LLM generator function type.
 */
export type LLMGenerator = (prompt: string) => Promise<string>;

/**
 * Result of a keep-alive tick.
 */
export interface KeepAliveTickResult {
  /** Whether a tick was performed */
  ticked: boolean;
  /** Whether the tick was skipped */
  skipped: boolean;
  /** Reason for skip (if skipped) */
  skipReason?: string;
  /** Generated thought (if ticked) */
  thought?: KeepAliveThought;
  /** Event emitted */
  event?: KeepAliveEvent;
}

/**
 * A thought generated by keep-alive.
 *
 * MIGRATION (PR4): `extractedGoal` is deprecated in favor of Sterling-provided
 * `committedGoalPropId`. The field is kept for backwards compatibility but
 * should not be used for semantic decisions.
 */
export interface KeepAliveThought {
  /** Unique thought ID */
  id: string;
  /** Thought content */
  content: string;
  /** Raw LLM output (before sanitization) */
  rawOutput: string;
  /**
   * @deprecated Use `committedGoalPropId` instead. Sterling is the semantic authority.
   * This field is kept for backwards compatibility during migration.
   */
  extractedGoal?: GoalTagV1 | null;
  /** Grounding result (from Sterling) */
  groundingResult: GroundingResult | null;
  /** Eligibility derivation (from Sterling) */
  eligibility: EligibilityOutput;
  /** Thought source */
  source: 'keepalive';
  /** Timestamp */
  timestamp: number;
  /** Frame profile used */
  frameProfile: string;
  // Sterling metadata (for observability)
  /** Whether Sterling was used for semantic processing */
  sterlingUsed?: boolean;
  /** Whether the result is executable (from Sterling) */
  isExecutable?: boolean;
  /** Block reason if not executable */
  blockReason?: string | null;
  /** Envelope ID for provenance */
  envelopeId?: string | null;
  /** Processing duration in ms */
  processingDurationMs?: number;
  /** Sterling-committed goal proposition ID (stable identity) */
  committedGoalPropId?: string | null;
  /** Sterling-committed IR digest (provenance) */
  committedIrDigest?: string | null;
  /** Whether grounding was performed */
  groundingPerformed?: boolean;
}

/**
 * Context for keep-alive ticks.
 */
export interface KeepAliveContext {
  /** Bot's current state */
  currentState: {
    position?: { x: number; y: number; z: number };
    health?: number;
    food?: number;
    inventory?: Array<{ name: string; count: number; displayName?: string }>;
    timeOfDay?: number;
    weather?: string;
    biome?: string;
    dimension?: string;
    nearbyHostiles?: number;
    nearbyPassives?: number;
  };
  /** Recent events */
  recentEvents?: Array<{
    type: string;
    timestamp: number;
    data: unknown;
  }>;
  /** Memory context */
  memoryContext?: {
    recentMemories?: Array<{
      content: string;
      type: string;
      timestamp: number;
    }>;
  };
  /** Active plan steps count */
  activePlanSteps: number;
  /** Recent task conversions count */
  recentTaskConversions: number;
  /** Last user command timestamp */
  lastUserCommand: number;
  /** Recent stimulus (for acceleration) */
  recentStimulus?: string;
}

// ============================================================================
// Keep-Alive Controller Class
// ============================================================================

/**
 * Controller for the keep-alive intention check loop.
 *
 * Emits events:
 * - 'tick': When a tick occurs
 * - 'thought': When a thought is generated
 * - 'skip': When a tick is skipped
 * - 'error': When an error occurs
 */
export class KeepAliveController extends EventEmitter {
  private config: KeepAliveConfig;
  private llmGenerator: LLMGenerator;
  private frameProfile: FrameProfile;

  // State tracking
  private lastTickTime = 0;
  private tickCount = 0;
  private consecutiveNoGoalTicks = 0;
  private refreshTimestamps: number[] = [];
  private circuitBreakerOpenUntil = 0;

  // Counters for observability
  private counters = {
    ticks: 0,
    thoughts: 0,
    skips: 0,
    goals: 0,
    eligibleGoals: 0,
  };

  constructor(llmGenerator: LLMGenerator, config: Partial<KeepAliveConfig> = {}) {
    super();

    this.config = { ...DEFAULT_KEEPALIVE_CONFIG, ...config };
    this.llmGenerator = llmGenerator;
    this.frameProfile = FRAME_PROFILES[this.config.frameProfile];
  }

  /**
   * Attempt a keep-alive tick.
   *
   * This is the main entry point. Call this periodically.
   * The controller will handle idle detection, rate limiting, etc.
   *
   * @param context - Current bot context
   * @returns Tick result
   */
  async tick(context: KeepAliveContext): Promise<KeepAliveTickResult> {
    const now = Date.now();

    // Check idle conditions (LF-9)
    const idleContext = this.buildIdleContextFromKeepAliveContext(context);
    const idleDecision = detectIdle(idleContext, this.config.idleConfig);

    if (!idleDecision.isIdle) {
      const event = createSkipNotIdleEvent({
        reason: idleDecision.reason as any,
        context: { nextCheckMs: idleDecision.nextCheckMs },
      });
      this.emit('skip', event);
      this.counters.skips++;

      return {
        ticked: false,
        skipped: true,
        skipReason: idleDecision.reason,
        event,
      };
    }

    // Check rate limiting
    const effectiveInterval = this.computeEffectiveInterval(context.recentStimulus);
    const timeSinceLastTick = now - this.lastTickTime;

    if (timeSinceLastTick < effectiveInterval) {
      const event = createSkipNotIdleEvent({
        reason: 'recent_task_conversion', // Use closest match
        context: { remainingMs: effectiveInterval - timeSinceLastTick },
      });
      this.counters.skips++;

      return {
        ticked: false,
        skipped: true,
        skipReason: 'cooldown',
        event,
      };
    }

    // Check circuit breaker
    if (this.isCircuitBreakerOpen(now)) {
      const event = createSkipNotIdleEvent({
        reason: 'critical_threat', // Use closest match
        context: { reopenAt: this.circuitBreakerOpenUntil },
      });
      this.counters.skips++;

      return {
        ticked: false,
        skipped: true,
        skipReason: 'circuit_breaker',
        event,
      };
    }

    // Perform the tick
    try {
      const thought = await this.generateThought(context);
      this.lastTickTime = now;
      this.tickCount++;
      this.counters.ticks++;
      this.counters.thoughts++;

      // Track consecutive no-goal ticks for steady state detection
      if (!thought.extractedGoal) {
        this.consecutiveNoGoalTicks++;
      } else {
        this.consecutiveNoGoalTicks = 0;
        this.counters.goals++;
        if (thought.eligibility.convertEligible) {
          this.counters.eligibleGoals++;
        }
      }

      // Emit events
      const tickEvent = createTickEvent({
        frame_kind: 'factual_only',
        no_suggested_goals: true,
        fact_count: this.frameProfile.factsBudget,
        acceleration_factor: this.computeAccelerationFactor(context.recentStimulus),
        effective_interval_ms: effectiveInterval,
      });

      const thoughtEvent = createThoughtEvent({
        thought_id: thought.id,
        convert_eligible: thought.eligibility.convertEligible,
        derived: thought.eligibility.derived,
        reasoning: thought.eligibility.reasoning,
        goal_present: thought.extractedGoal !== null,
        grounding_pass: thought.groundingResult?.pass ?? null,
        source: 'keepalive',
      });

      this.emit('tick', tickEvent);
      this.emit('thought', thoughtEvent, thought);

      return {
        ticked: true,
        skipped: false,
        thought,
        event: thoughtEvent,
      };
    } catch (error) {
      this.emit('error', error);
      return {
        ticked: false,
        skipped: true,
        skipReason: `error: ${(error as Error).message}`,
      };
    }
  }

  /**
   * Generate a thought from the current context.
   *
   * This method now uses the Sterling-based async pipeline (processLLMOutputAsync)
   * which routes through Sterling for semantic authority. If Sterling is unavailable,
   * it falls back to the legacy sync pipeline.
   *
   * Key invariant: Advisory-only outputs (natural language intent without explicit
   * [GOAL:] tags) will have isExecutable=false and will NOT be converted to tasks.
   */
  private async generateThought(context: KeepAliveContext): Promise<KeepAliveThought> {
    // Convert context to frame context
    const frameContext = thoughtContextToFrameContext({
      currentState: context.currentState,
      recentEvents: context.recentEvents,
      memoryContext: context.memoryContext,
    });

    // Render situation frame using production code
    const situationFrame = renderSituationFrame(frameContext, this.frameProfile);

    // Render prompt
    const prompt = renderIntentionCheckPrompt(
      situationFrame.text,
      this.config.promptVariant
    );

    // Generate via LLM
    const rawOutput = await this.llmGenerator(prompt);

    // Build grounding context
    const groundingContext = this.buildGroundingContext(context);

    // Process output using Sterling-based async pipeline
    // This is the CANONICAL path that routes through Sterling for semantic authority
    const result = await processLLMOutputAsync(rawOutput, groundingContext);

    // Create thought object with Sterling metadata
    // PR4: extractedGoal is deprecated — use committedGoalPropId for identity
    const thought: KeepAliveThought = {
      id: `keepalive-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
      content: result.text,
      rawOutput,
      // DEPRECATED: extractedGoal — Sterling provides identity via committedGoalPropId
      extractedGoal: undefined,
      groundingResult: result.grounding,
      eligibility: result.eligibility,
      source: 'keepalive',
      timestamp: Date.now(),
      frameProfile: this.frameProfile.name,
      // Sterling metadata for observability and identity
      sterlingUsed: result.sterlingUsed,
      isExecutable: result.isExecutable,
      blockReason: result.blockReason,
      envelopeId: result.envelopeId,
      processingDurationMs: result.durationMs,
      // Sterling-provided identity (replaces canonicalGoalKey and extractedGoal)
      committedGoalPropId: result.reducerResult?.committed_goal_prop_id ?? null,
      committedIrDigest: result.reducerResult?.committed_ir_digest ?? null,
      groundingPerformed: result.groundingPerformed,
    };

    // Validate invariants
    this.validateInvariants(thought, result);

    return thought;
  }

  /**
   * Build idle context from keep-alive context.
   */
  private buildIdleContextFromKeepAliveContext(context: KeepAliveContext): IdleContext {
    const threatLevel = estimateThreatLevel(context.currentState.nearbyHostiles ?? 0);

    return buildIdleContext({
      activePlanSteps: context.activePlanSteps,
      recentTaskConversions: context.recentTaskConversions,
      threatLevel,
      lastUserCommand: context.lastUserCommand,
      lastKeepAliveTick: this.lastTickTime,
    });
  }

  /**
   * Build grounding context from keep-alive context.
   */
  private buildGroundingContext(context: KeepAliveContext): GroundingContext {
    return {
      bot: {
        health: context.currentState.health ?? 20,
        hunger: context.currentState.food ?? 20,
        inventory: (context.currentState.inventory ?? []).map(i => ({
          name: i.displayName || i.name,
          count: i.count,
        })),
        position: context.currentState.position,
      },
      world: {
        biome: context.currentState.biome ?? 'unknown',
        nearbyEntities: [], // Would need entity details
      },
    };
  }

  /**
   * Compute effective interval based on stimulus acceleration.
   */
  private computeEffectiveInterval(recentStimulus?: string): number {
    const factor = this.computeAccelerationFactor(recentStimulus);
    const accelerated = Math.floor(this.config.baseIntervalMs / factor);
    return Math.max(accelerated, this.config.minIntervalMs);
  }

  /**
   * Compute acceleration factor for a stimulus.
   */
  private computeAccelerationFactor(recentStimulus?: string): number {
    if (!recentStimulus) return 1.0;
    return this.config.stimulusAcceleration[recentStimulus] ?? 1.0;
  }

  /**
   * Check if circuit breaker is open.
   */
  private isCircuitBreakerOpen(now: number): boolean {
    if (now < this.circuitBreakerOpenUntil) {
      return true;
    }

    // Clean old timestamps
    const oneMinuteAgo = now - 60_000;
    this.refreshTimestamps = this.refreshTimestamps.filter(t => t > oneMinuteAgo);

    // Check if we've exceeded the limit
    if (this.refreshTimestamps.length >= this.config.maxRefreshesPerMinute) {
      // Open the circuit breaker for 1 minute
      this.circuitBreakerOpenUntil = now + 60_000;
      return true;
    }

    // Record this refresh
    this.refreshTimestamps.push(now);
    return false;
  }

  /**
   * Validate keep-alive invariants.
   */
  private validateInvariants(
    thought: KeepAliveThought,
    result: { eligibility: EligibilityOutput }
  ): void {
    // Check I-1: No goal injection in the frame
    // (validated by construction — we use factual-only frames)

    // Check LF-2: Eligibility must be derived
    if (result.eligibility.derived !== true) {
      const violation = createViolationEvent({
        invariant: 'LF-2',
        description: 'Eligibility was not derived through the single choke point',
        data: { derived: result.eligibility.derived },
      });
      this.emit('violation', violation);
    }

    // Check eligibility rule: (goal_present && grounding_pass) === convertEligible
    const goalPresent = thought.extractedGoal !== null;
    const groundingPass = thought.groundingResult?.pass === true;
    const expectedEligible = goalPresent && groundingPass;

    if (thought.eligibility.convertEligible !== expectedEligible) {
      const violation = createViolationEvent({
        invariant: 'eligibility_rule',
        description: 'Eligibility rule violated: (goal_present && grounding_pass) !== convertEligible',
        data: {
          goalPresent,
          groundingPass,
          expectedEligible,
          actualEligible: thought.eligibility.convertEligible,
        },
      });
      this.emit('violation', violation);
    }
  }

  /**
   * Get current counters for observability.
   */
  getCounters(): typeof this.counters {
    return { ...this.counters };
  }

  /**
   * Get state for diagnostics.
   */
  getState(): {
    lastTickTime: number;
    tickCount: number;
    consecutiveNoGoalTicks: number;
    circuitBreakerOpenUntil: number;
    refreshCountLastMinute: number;
  } {
    const now = Date.now();
    const oneMinuteAgo = now - 60_000;
    const refreshCountLastMinute = this.refreshTimestamps.filter(t => t > oneMinuteAgo).length;

    return {
      lastTickTime: this.lastTickTime,
      tickCount: this.tickCount,
      consecutiveNoGoalTicks: this.consecutiveNoGoalTicks,
      circuitBreakerOpenUntil: this.circuitBreakerOpenUntil,
      refreshCountLastMinute,
    };
  }

  /**
   * Reset the controller state.
   */
  reset(): void {
    this.lastTickTime = 0;
    this.tickCount = 0;
    this.consecutiveNoGoalTicks = 0;
    this.refreshTimestamps = [];
    this.circuitBreakerOpenUntil = 0;
    this.counters = {
      ticks: 0,
      thoughts: 0,
      skips: 0,
      goals: 0,
      eligibleGoals: 0,
    };
  }
}
