diff --git a/lib/mineflayer.js b/lib/mineflayer.js
index 06634bf6415ec41410e95ec816bebcc239726497..f634efe72acaa1431cdd8890b9bb98f50cb39b63 100644
--- a/lib/mineflayer.js
+++ b/lib/mineflayer.js
@@ -71,8 +71,17 @@ module.exports = (bot, { viewDistance = 6, firstPerson = false, port = 3000, pre
 
     bot.on('move', botPosition)
     worldView.listenToBot(bot)
+
+    function emitTime () {
+      const time = (bot.time && bot.time.timeOfDay != null) ? bot.time.timeOfDay : (bot.world && bot.world.time != null ? bot.world.time : 6000)
+      socket.emit('time', time)
+    }
+    emitTime()
+    bot.on('time', emitTime)
+
     socket.on('disconnect', () => {
       bot.removeListener('move', botPosition)
+      bot.removeListener('time', emitTime)
       worldView.removeListenersFromBot(bot)
       sockets.splice(sockets.indexOf(socket), 1)
     })
diff --git a/viewer/lib/entity/Entity.js b/viewer/lib/entity/Entity.js
index 89454526bd0c58e167fa4cc787cf1892ea26297f..510e545e62a86a8f8398df13fb8218a61abf2ee4 100644
--- a/viewer/lib/entity/Entity.js
+++ b/viewer/lib/entity/Entity.js
@@ -200,10 +200,23 @@ function getMesh (texture, jsonModel) {
   return mesh
 }
 
+/** Fallbacks for entities missing geometry (prismarine-viewer gaps) */
+const ENTITY_FALLBACKS = { glow_squid: 'squid' }
+const ENTITY_SKIP = new Set(['item']) // No geometry for dropped items
+
 class Entity {
   constructor (version, type, scene) {
-    const e = entities[type]
-    if (!e) throw new Error(`Unknown entity ${type}`)
+    let e = entities[type]
+    if (!e && ENTITY_FALLBACKS[type]) {
+      e = entities[ENTITY_FALLBACKS[type]]
+    }
+    if (!e) {
+      if (ENTITY_SKIP.has(type)) {
+        this.mesh = new THREE.Object3D()
+        return
+      }
+      throw new Error(`Unknown entity ${type}`)
+    }
 
     this.mesh = new THREE.Object3D()
     for (const [name, jsonModel] of Object.entries(e.geometry)) {
diff --git a/viewer/lib/utils.web.js b/viewer/lib/utils.web.js
index 72d715b90ee64aa339159de4b2e3471180c02266..03b5d5ba1ca716182746b24b0db1c77ad3e61875 100644
--- a/viewer/lib/utils.web.js
+++ b/viewer/lib/utils.web.js
@@ -2,25 +2,49 @@
 const THREE = require('three')
 
 const textureCache = {}
-function loadTexture (texture, cb) {
-  if (!textureCache[texture]) {
-    textureCache[texture] = new THREE.TextureLoader().load(texture)
+function loadTexture (url, cb) {
+  const resolved = url.startsWith('/') ? url : (typeof window !== 'undefined' && window.location ? new URL(url, window.location.origin).pathname : '/' + url.replace(/^\//, ''))
+  if (textureCache[resolved]) {
+    cb(textureCache[resolved])
+    return
   }
-  cb(textureCache[texture])
+  if (textureCache[resolved] === null) {
+    cb(null)
+    return
+  }
+  const loader = new THREE.TextureLoader()
+  loader.load(
+    resolved,
+    (tex) => {
+      textureCache[resolved] = tex
+      cb(tex)
+    },
+    undefined,
+    (err) => {
+      console.warn('[prismarine-viewer] Texture load failed:', resolved, err)
+      textureCache[resolved] = null
+      cb(null)
+    }
+  )
 }
 
 function loadJSON (url, callback) {
+  const resolved = url.startsWith('/') ? url : (typeof window !== 'undefined' && window.location ? new URL(url, window.location.origin).pathname : '/' + url.replace(/^\//, ''))
   const xhr = new XMLHttpRequest()
-  xhr.open('GET', url, true)
+  xhr.open('GET', resolved, true)
   xhr.responseType = 'json'
   xhr.onload = function () {
-    const status = xhr.status
-    if (status === 200) {
+    if (xhr.status === 200) {
       callback(xhr.response)
     } else {
-      throw new Error(url + ' not found')
+      console.warn('[prismarine-viewer] JSON load failed:', resolved, xhr.status)
+      callback(null)
     }
   }
+  xhr.onerror = function () {
+    console.warn('[prismarine-viewer] JSON load error:', resolved)
+    callback(null)
+  }
   xhr.send()
 }
 
diff --git a/viewer/lib/viewer.js b/viewer/lib/viewer.js
index db02d904690f4066555dbea72b00dd11fbd99640..b63729acd40c6b4e059c74ab22e224cab2295128 100644
--- a/viewer/lib/viewer.js
+++ b/viewer/lib/viewer.js
@@ -82,6 +82,60 @@ class Viewer {
     this.camera.rotation.set(pitch, yaw, 0, 'ZYX')
   }
 
+  /**
+   * Update sky and lighting from Minecraft time (0-24000).
+   * 0=sunrise, 6000=noon, 12000=sunset, 18000=midnight
+   */
+  updateTime (time) {
+    if (time == null || typeof time !== 'number') return
+    const t = ((time % 24000) + 24000) % 24000
+    const cycle = t / 24000
+
+    let r, g, b
+    if (t >= 0 && t < 2000) {
+      const u = t / 2000
+      r = 0.4 + 0.35 * u
+      g = 0.5 + 0.25 * u
+      b = 0.9
+    } else if (t >= 2000 && t < 10000) {
+      r = 0.75
+      g = 0.85
+      b = 1
+    } else if (t >= 10000 && t < 12000) {
+      const u = (t - 10000) / 2000
+      r = 0.75 + 0.25 * u
+      g = 0.85 - 0.35 * u
+      b = 1 - 0.5 * u
+    } else if (t >= 12000 && t < 14000) {
+      const u = (t - 12000) / 2000
+      r = 0.15 + 0.1 * u
+      g = 0.1 + 0.05 * u
+      b = 0.3 + 0.1 * u
+    } else if (t >= 14000 && t < 22000) {
+      r = 0.08
+      g = 0.06
+      b = 0.18
+    } else {
+      const u = (t - 22000) / 2000
+      r = 0.08 + 0.32 * u
+      g = 0.06 + 0.44 * u
+      b = 0.18 + 0.72 * u
+    }
+    this.scene.background = new THREE.Color(r, g, b)
+
+    const isDay = t >= 23500 || t < 12500
+    const ambient = isDay ? 0.8 : 0.25
+    const directional = isDay ? 0.5 : 0.1
+    this.ambientLight.intensity = ambient
+    this.ambientLight.color.setRGB(1, 1, 1)
+    this.directionalLight.intensity = directional
+    this.directionalLight.position.set(
+      Math.cos(cycle * Math.PI * 2 - Math.PI / 2) * 0.5 + 0.5,
+      0.8,
+      Math.sin(cycle * Math.PI * 2 - Math.PI / 2) * 0.5 + 0.5
+    ).normalize()
+  }
+
   listen (emitter) {
     emitter.on('entity', (e) => {
       this.updateEntity(e)
@@ -103,6 +157,10 @@ class Viewer {
       this.setBlockStateId(new Vec3(pos.x, pos.y, pos.z), stateId)
     })
 
+    emitter.on('time', (time) => {
+      this.updateTime(time)
+    })
+
     this.domElement.addEventListener('pointerdown', (evt) => {
       const raycaster = new THREE.Raycaster()
       const mouse = new THREE.Vector2()
diff --git a/viewer/lib/worldrenderer.js b/viewer/lib/worldrenderer.js
index 744224a71ec6d73b3da405df9f8a5fdd55dfbd66..4b6891684b482140bf118933bde025de7bb7d84d 100644
--- a/viewer/lib/worldrenderer.js
+++ b/viewer/lib/worldrenderer.js
@@ -21,7 +21,14 @@ class WorldRenderer {
     this.blockStatesData = undefined
     this.texturesDataUrl = undefined
 
-    this.material = new THREE.MeshLambertMaterial({ vertexColors: true, transparent: true, alphaTest: 0.1 })
+    this.material = new THREE.MeshPhongMaterial({
+      vertexColors: true,
+      transparent: true,
+      alphaTest: 0.1,
+      specular: 0x333333,
+      shininess: 15,
+      flatShading: false
+    })
 
     this.workers = []
     for (let i = 0; i < numWorkers; i++) {
@@ -87,24 +94,39 @@ class WorldRenderer {
   }
 
   updateTexturesData () {
-    loadTexture(this.texturesDataUrl || `textures/${this.version}.png`, texture => {
+    const url = this.texturesDataUrl || `/textures/${this.version}.png`
+    loadTexture(url, texture => {
+      if (!texture) return
       texture.magFilter = THREE.NearestFilter
       texture.minFilter = THREE.NearestFilter
       texture.flipY = false
+      texture.generateMipmaps = false
       this.material.map = texture
     })
 
     const loadBlockStates = () => {
-      return new Promise(resolve => {
+      return new Promise((resolve, reject) => {
         if (this.blockStatesData) return resolve(this.blockStatesData)
-        return loadJSON(`blocksStates/${this.version}.json`, resolve)
+        const blockStatesUrl = `/blocksStates/${this.version}.json`
+        loadJSON(blockStatesUrl, (data) => {
+          if (data) {
+            this.blockStatesData = data
+            resolve(data)
+          } else {
+            reject(new Error('blocksStates load failed: ' + blockStatesUrl))
+          }
+        })
       })
     }
-    loadBlockStates().then((blockStates) => {
-      for (const worker of this.workers) {
-        worker.postMessage({ type: 'blockStates', json: blockStates })
-      }
-    })
+    loadBlockStates()
+      .then((blockStates) => {
+        for (const worker of this.workers) {
+          worker.postMessage({ type: 'blockStates', json: blockStates })
+        }
+      })
+      .catch((err) => {
+        console.warn('[prismarine-viewer] blocksStates load failed:', err)
+      })
   }
 
   addColumn (x, z, chunk) {
